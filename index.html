<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Connect 4 (2P / 1P vs AI + Advanced/Elite/World Class)</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33;
      --grid:#1a2550;
      --cell:#0f1838;
      --p1:#ff3b30;   /* Red */
      --p2:#ffcc00;   /* Yellow */
      --text:#e8ecff;
      --muted:#a9b3d6;
      --shadow: 0 12px 40px rgba(0,0,0,.35);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(1200px 800px at 20% 10%, #2c3aa8 0%, transparent 55%),
        radial-gradient(1000px 700px at 85% 35%, #7a2da8 0%, transparent 60%),
        var(--bg);
      color:var(--text);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial;
      padding:24px;
    }
    .app{
      width:min(1100px, 100%);
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:18px;
    }
    @media (max-width: 900px){
      .app{ grid-template-columns: 1fr; }
    }
    .card{
      background: rgba(18,26,51,.88);
      border:1px solid rgba(255,255,255,.08);
      border-radius:16px;
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    header{
      padding:18px 18px 12px;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.06), transparent);
    }
    header h1{
      margin:0;
      font-size:18px;
      letter-spacing:.3px;
    }
    header p{
      margin:6px 0 0;
      color:var(--muted);
      font-size:13px;
      line-height:1.4;
    }
    .controls{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    button, select, label.switch{
      border:1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color:var(--text);
      border-radius:12px;
      font-weight:800;
      font-size:13px;
    }
    button{
      padding:10px 12px;
      cursor:pointer;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
    }
    button:hover{ background: rgba(255,255,255,.10); border-color: rgba(255,255,255,.22); }
    button:active{ transform: translateY(1px); }
    select{
      padding:10px 12px;
      cursor:pointer;
      outline:none;
    }
    .boardWrap{
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }
    .topHint{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      color:var(--muted);
      font-size:13px;
      flex-wrap:wrap;
    }
    .turnDot{
      width:10px; height:10px; border-radius:50%;
      display:inline-block; margin-right:8px;
      background: var(--p1);
      box-shadow: 0 0 0 4px rgba(255,255,255,.06);
      vertical-align:middle;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.18);
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }
    .grid{
      width:100%;
      aspect-ratio: 7 / 6;
      background: linear-gradient(180deg, rgba(255,255,255,.05), transparent), var(--grid);
      border-radius:18px;
      padding:14px;
      display:grid;
      grid-template-columns: repeat(7, 1fr);
      grid-template-rows: repeat(6, 1fr);
      gap:10px;
      position:relative;
      user-select:none;
    }
    .cell{
      background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.08), transparent 55%), var(--cell);
      border-radius:999px;
      border:1px solid rgba(255,255,255,.08);
      position:relative;
      overflow:hidden;
      cursor:pointer;
    }
    .disc{
      position:absolute;
      inset:0;
      border-radius:999px;
      transform: translateY(-140%);
      transition: transform 240ms cubic-bezier(.2,.9,.2,1), filter .2s ease;
      filter: drop-shadow(0 10px 10px rgba(0,0,0,.25));
    }
    .disc.p1{ background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.35), transparent 55%), var(--p1); }
    .disc.p2{ background: radial-gradient(circle at 30% 25%, rgba(255,255,255,.35), transparent 55%), var(--p2); }
    .disc.set{ transform: translateY(0); }
    .cell.win{
      outline: 3px solid rgba(255,255,255,.25);
      box-shadow: 0 0 0 6px rgba(255,255,255,.06);
    }
    .side{
      padding:18px;
      display:flex;
      flex-direction:column;
      gap:14px;
    }
    .status{
      padding:14px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      line-height:1.35;
    }
    .status .title{
      font-weight:900;
      letter-spacing:.2px;
      margin-bottom:6px;
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
    }
    .legend{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }
    .legend .pill{
      padding:12px;
      border-radius:14px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.03);
      display:flex;
      align-items:center;
      justify-content:space-between;
      font-weight:900;
    }
    .dot{ width:14px; height:14px; border-radius:50%; display:inline-block; }
    .dot.p1{ background: var(--p1); }
    .dot.p2{ background: var(--p2); }
    .small{ color:var(--muted); font-size:12px; line-height:1.5; }

    .toggleRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
    }
    .switch{
      display:inline-flex;
      align-items:center;
      gap:10px;
      padding:10px 12px;
      cursor:pointer;
      user-select:none;
    }
    .switch input{ display:none; }
    .track{
      width:44px; height:24px;
      border-radius:999px;
      background: rgba(255,255,255,.18);
      position:relative;
      border:1px solid rgba(255,255,255,.18);
    }
    .thumb{
      width:18px; height:18px; border-radius:50%;
      background: rgba(255,255,255,.85);
      position:absolute; top:50%; left:3px;
      transform: translateY(-50%);
      transition: left .18s ease;
    }
    .switch input:checked + .track .thumb{ left:22px; }
    .switchText{ font-weight:900; }
    .aiNote{ color:var(--muted); font-weight:800; font-size:12px; }
  </style>
</head>
<body>
  <div class="app">
    <div class="card">
      <header>
        <div>
          <h1>Connect 4</h1>
          <p>Click a column to drop. Keys: <b>1–7</b> drop, <b>U</b> undo, <b>R</b> reset.</p>
        </div>
        <div class="controls">
          <button id="newGameBtn">New Game</button>
          <button id="undoBtn" title="Undo (U)">Undo</button>
        </div>
      </header>

      <div class="boardWrap">
        <div class="topHint">
          <div><span class="turnDot" id="turnDot"></span><span id="turnText">Red’s turn</span></div>
          <div class="badge" id="modeBadge">2-Player</div>
        </div>
        <div class="grid" id="grid" aria-label="Connect 4 board"></div>
        <div class="small" id="aiThinking" style="display:none;">AI is thinking…</div>
      </div>
    </div>

    <div class="card">
      <div class="side">
        <div class="status">
          <div class="title">
            Game Status <span class="badge" id="movesBadge">Moves: 0</span>
          </div>
          <div id="statusText">Red starts. Make your move.</div>
        </div>

        <div class="status">
          <div class="title">Mode</div>
          <div class="toggleRow">
            <label class="switch" title="Toggle AI on/off">
              <span class="switchText">1-Player vs AI</span>
              <input type="checkbox" id="aiToggle">
              <span class="track"><span class="thumb"></span></span>
            </label>
            <div class="aiNote" id="aiNote">AI OFF (2-Player)</div>
          </div>

          <div style="margin-top:12px; display:flex; gap:10px; flex-wrap:wrap; align-items:center;">
            <span class="badge">Difficulty</span>
            <select id="difficultySelect" disabled>
              <option value="easy">Easy</option>
              <option value="medium" selected>Medium</option>
              <option value="hard">Hard</option>
              <option value="advanced">Advanced</option>
              <option value="elite">Elite</option>
              <option value="worldclass">World Class</option>
            </select>
            <span class="badge">AI = Yellow</span>
          </div>

          <div class="small" style="margin-top:10px;">
            In 1-Player mode: <b>You = Red</b>, <b>AI = Yellow</b>.
          </div>
        </div>

        <div class="legend">
          <div class="pill">Red <span class="dot p1"></span></div>
          <div class="pill">Yellow <span class="dot p2"></span></div>
        </div>

        <div class="status">
          <div class="title">Notes</div>
          <div class="small">
            Advanced/Elite/World Class use deeper search + caching. World Class is extremely strong, but not a full solved-database engine.
          </div>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ====== CONSTANTS ======
    const ROWS = 6;
    const COLS = 7;
    const HUMAN = 1; // Red
    const AI = 2;    // Yellow

    // ====== STATE ======
    let board = makeEmptyBoard();
    let currentPlayer = HUMAN;
    let gameOver = false;
    let moveHistory = []; // stack of {r,c,player}
    let vsAI = false;
    let difficulty = "medium";
    let aiBusy = false;

    // ====== TRANSPOSITION TABLE (cache) ======
    const TT = new Map();
    const MAX_TT_SIZE = 120000;

    // ====== DOM ======
    const gridEl = document.getElementById('grid');
    const statusTextEl = document.getElementById('statusText');
    const turnTextEl = document.getElementById('turnText');
    const turnDotEl = document.getElementById('turnDot');
    const movesBadgeEl = document.getElementById('movesBadge');
    const modeBadgeEl = document.getElementById('modeBadge');
    const aiToggleEl = document.getElementById('aiToggle');
    const aiNoteEl = document.getElementById('aiNote');
    const difficultySelectEl = document.getElementById('difficultySelect');
    const aiThinkingEl = document.getElementById('aiThinking');
    const newGameBtn = document.getElementById('newGameBtn');
    const undoBtn = document.getElementById('undoBtn');

    buildGrid();
    wireEvents();
    newGame();

    function makeEmptyBoard(){
      return Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    }

    function buildGrid() {
      gridEl.innerHTML = '';
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.r = r;
          cell.dataset.c = c;

          const disc = document.createElement('div');
          disc.className = 'disc';
          cell.appendChild(disc);

          cell.addEventListener('click', () => handleColumnClick(c));
          gridEl.appendChild(cell);
        }
      }
    }

    function wireEvents(){
      newGameBtn.addEventListener('click', newGame);
      undoBtn.addEventListener('click', undo);

      aiToggleEl.addEventListener('change', () => {
        vsAI = aiToggleEl.checked;
        difficultySelectEl.disabled = !vsAI;
        aiNoteEl.textContent = vsAI ? "AI ON (1-Player)" : "AI OFF (2-Player)";
        modeBadgeEl.textContent = vsAI ? "1-Player vs AI" : "2-Player";

        if (vsAI && !gameOver && currentPlayer === AI && !aiBusy){
          scheduleAIMove();
        }
        updateUI();
      });

      difficultySelectEl.addEventListener('change', () => {
        difficulty = difficultySelectEl.value;
        statusTextEl.textContent = `Difficulty set to ${difficulty.toUpperCase()}.`;
      });

      window.addEventListener('keydown', (e) => {
        if (e.key >= '1' && e.key <= '7') handleColumnClick(Number(e.key) - 1);
        if (e.key.toLowerCase() === 'u') undo();
        if (e.key.toLowerCase() === 'r') newGame();
      });
    }

    function newGame(){
      board = makeEmptyBoard();
      currentPlayer = HUMAN;
      gameOver = false;
      moveHistory = [];
      aiBusy = false;
      aiThinkingEl.style.display = 'none';
      statusTextEl.textContent = "Red starts. Make your move.";
      modeBadgeEl.textContent = vsAI ? "1-Player vs AI" : "2-Player";
      updateUI();
    }

    function undo(){
      if (moveHistory.length === 0 || aiBusy) return;

      const undoCount = (vsAI ? Math.min(2, moveHistory.length) : 1);
      for (let i = 0; i < undoCount; i++){
        const last = moveHistory.pop();
        if (!last) break;
        board[last.r][last.c] = 0;
        currentPlayer = last.player;
      }
      gameOver = false;
      statusTextEl.textContent = vsAI ? "Undid your move + AI move." : "Undid last move.";
      updateUI();
    }

    function handleColumnClick(col){
      if (gameOver || aiBusy) return;
      if (vsAI && currentPlayer === AI) return;

      const row = getDropRow(board, col);
      if (row === -1){
        statusTextEl.textContent = "That column is full. Pick another.";
        return;
      }

      placeDisc(row, col, currentPlayer);

      const win = checkWinFrom(board, row, col, currentPlayer);
      if (win.won){
        gameOver = true;
        updateUI(win.cells);
        statusTextEl.innerHTML = `<b>${currentPlayer === HUMAN ? "Red" : "Yellow"} wins!</b> Press New Game (R).`;
        turnTextEl.textContent = "Game over";
        return;
      }

      if (isBoardFull(board)){
        gameOver = true;
        updateUI();
        statusTextEl.innerHTML = `<b>Draw!</b> Press New Game (R).`;
        turnTextEl.textContent = "Game over";
        return;
      }

      currentPlayer = (currentPlayer === HUMAN ? AI : HUMAN);
      statusTextEl.textContent = "Good move.";
      updateUI();

      if (vsAI && currentPlayer === AI && !gameOver) scheduleAIMove();
    }

    function placeDisc(row, col, player){
      board[row][col] = player;
      moveHistory.push({ r: row, c: col, player });
    }

    function scheduleAIMove(){
      aiBusy = true;
      aiThinkingEl.style.display = 'block';
      statusTextEl.textContent = "AI is thinking…";
      updateUI();

      const delay =
        (difficulty === "worldclass" ? 650 :
         difficulty === "elite" ? 520 :
         difficulty === "advanced" ? 440 :
         difficulty === "hard" ? 360 :
         difficulty === "medium" ? 280 : 220);

      setTimeout(() => {
        const col = chooseAIMove(board, difficulty);
        const row = getDropRow(board, col);

        if (row === -1){
          const valid = getValidMoves(board);
          const fallbackCol = valid[Math.floor(Math.random() * valid.length)];
          const fallbackRow = getDropRow(board, fallbackCol);
          placeDisc(fallbackRow, fallbackCol, AI);
        } else {
          placeDisc(row, col, AI);
        }

        const last = moveHistory[moveHistory.length - 1];
        const win = checkWinFrom(board, last.r, last.c, AI);

        aiBusy = false;
        aiThinkingEl.style.display = 'none';

        if (win.won){
          gameOver = true;
          updateUI(win.cells);
          statusTextEl.innerHTML = `<b>AI (Yellow) wins!</b> Press New Game (R).`;
          turnTextEl.textContent = "Game over";
          return;
        }

        if (isBoardFull(board)){
          gameOver = true;
          updateUI();
          statusTextEl.innerHTML = `<b>Draw!</b> Press New Game (R).`;
          turnTextEl.textContent = "Game over";
          return;
        }

        currentPlayer = HUMAN;
        statusTextEl.textContent = "Your turn.";
        updateUI();
      }, delay);
    }

    function updateUI(winningCells = null){
      const cells = gridEl.querySelectorAll('.cell');
      cells.forEach(cell => {
        cell.classList.remove('win');
        const r = Number(cell.dataset.r);
        const c = Number(cell.dataset.c);
        const val = board[r][c];
        const disc = cell.firstElementChild;
        disc.className = 'disc';
        if (val === HUMAN) disc.classList.add('p1', 'set');
        if (val === AI) disc.classList.add('p2', 'set');
      });

      if (winningCells && winningCells.length){
        winningCells.forEach(([r,c]) => {
          const el = gridEl.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
          if (el) el.classList.add('win');
        });
      }

      movesBadgeEl.textContent = `Moves: ${moveHistory.length}`;
      modeBadgeEl.textContent = vsAI ? "1-Player vs AI" : "2-Player";

      if (!gameOver){
        if (currentPlayer === HUMAN){
          turnTextEl.textContent = vsAI ? "Your turn (Red)" : "Red’s turn";
          turnDotEl.style.background = 'var(--p1)';
        } else {
          turnTextEl.textContent = vsAI ? "AI’s turn (Yellow)" : "Yellow’s turn";
          turnDotEl.style.background = 'var(--p2)';
        }
      }
    }

    // ====== GAME LOGIC ======
    function getDropRow(b, col){
      for (let r = ROWS - 1; r >= 0; r--){
        if (b[r][col] === 0) return r;
      }
      return -1;
    }

    function isBoardFull(b){
      for (let c = 0; c < COLS; c++){
        if (b[0][c] === 0) return false;
      }
      return true;
    }

    function inBounds(r,c){
      return r >= 0 && r < ROWS && c >= 0 && c < COLS;
    }

    function checkWinFrom(b, row, col, player){
      const dirs = [[0,1],[1,0],[1,1],[1,-1]];
      for (const [dr, dc] of dirs){
        const cells = [[row, col]];
        let r = row + dr, c = col + dc;
        while (inBounds(r,c) && b[r][c] === player){ cells.push([r,c]); r += dr; c += dc; }
        r = row - dr; c = col - dc;
        while (inBounds(r,c) && b[r][c] === player){ cells.unshift([r,c]); r -= dr; c -= dc; }
        if (cells.length >= 4) return { won:true, cells };
      }
      return { won:false, cells:[] };
    }

    function getValidMoves(b){
      const moves = [];
      for (let c = 0; c < COLS; c++){
        if (b[0][c] === 0) moves.push(c);
      }
      return moves;
    }

    // ====== AI (Advanced/Elite/World Class) ======
    function chooseAIMove(b, diff){
      const validMoves = getValidMoves(b);
      if (validMoves.length === 0) return 0;

      // Tactical IQ first: win now, block now
      const winMove = findImmediateWin(b, AI);
      if (winMove !== null) return winMove;

      const blockMove = findImmediateWin(b, HUMAN);
      if (blockMove !== null) return blockMove;

      const presets = {
        easy:       { depth: 1, randomness: 0.60 },
        medium:     { depth: 2, randomness: 0.20 },
        hard:       { depth: 4, randomness: 0.05 },
        advanced:   { depth: 6, randomness: 0.02 },
        elite:      { depth: 7, randomness: 0.00 },
        worldclass: { depth: 8, randomness: 0.00 } // very strong (not solved DB)
      };
      const p = presets[diff] || presets.medium;

      // Easier modes: a touch of randomness
      if (p.randomness > 0 && Math.random() < p.randomness){
        const ordered = validMoves.slice().sort((a,z) => Math.abs(a-3) - Math.abs(z-3));
        return ordered[Math.floor(Math.random() * Math.min(3, ordered.length))];
      }

      // Advanced+ uses caching for speed
      if (diff === "advanced" || diff === "elite" || diff === "worldclass"){
        return minimaxRootCached(b, p.depth, AI);
      }
      return minimaxRoot(b, p.depth, AI);
    }

    function cloneBoard(b){ return b.map(row => row.slice()); }

    function simulateDrop(b, col, player){
      const nb = cloneBoard(b);
      const r = getDropRow(nb, col);
      if (r === -1) return null;
      nb[r][col] = player;
      return { board: nb, row: r, col };
    }

    function findImmediateWin(b, player){
      const valid = getValidMoves(b);
      for (const col of valid){
        const sim = simulateDrop(b, col, player);
        if (!sim) continue;
        if (checkWinFrom(sim.board, sim.row, sim.col, player).won) return col;
      }
      return null;
    }

    function centerBias(col){ return 6 - Math.abs(col - 3); }

    // --------- Minimax (no cache) ----------
    function minimaxRoot(b, depth, player){
      const valid = getValidMoves(b).slice().sort((a,z) => Math.abs(a-3) - Math.abs(z-3));
      let bestCol = valid[0];
      let bestVal = -Infinity;

      for (const col of valid){
        const sim = simulateDrop(b, col, player);
        if (!sim) continue;
        if (checkWinFrom(sim.board, sim.row, sim.col, player).won) return col;

        const val = minimax(sim.board, depth - 1, false, -Infinity, Infinity);
        const total = val + centerBias(col) * 0.2;

        if (total > bestVal){
          bestVal = total;
          bestCol = col;
        }
      }
      return bestCol;
    }

    function minimax(b, depth, maximizing, alpha, beta){
      const valid = getValidMoves(b);

      if (depth === 0 || valid.length === 0){
        return (evaluateBoard(b, AI) - evaluateBoard(b, HUMAN) * 0.9);
      }

      const aiWin = findImmediateWin(b, AI);
      const huWin = findImmediateWin(b, HUMAN);
      if (aiWin !== null) return 100000;
      if (huWin !== null) return -100000;

      const ordered = valid.slice().sort((a,z) => Math.abs(a-3) - Math.abs(z-3));

      if (maximizing){
        let best = -Infinity;
        for (const col of ordered){
          const sim = simulateDrop(b, col, AI);
          if (!sim) continue;
          const val = minimax(sim.board, depth - 1, false, alpha, beta);
          best = Math.max(best, val);
          alpha = Math.max(alpha, best);
          if (beta <= alpha) break;
        }
        return best;
      } else {
        let best = Infinity;
        for (const col of ordered){
          const sim = simulateDrop(b, col, HUMAN);
          if (!sim) continue;
          const val = minimax(sim.board, depth - 1, true, alpha, beta);
          best = Math.min(best, val);
          beta = Math.min(beta, best);
          if (beta <= alpha) break;
        }
        return best;
      }
    }

    // --------- Minimax with cache (transposition table) ----------
    function boardKey(b, playerTurn){
      return playerTurn + "|" + b.map(row => row.join("")).join("/");
    }

    function TTSet(key, val){
      if (TT.size > MAX_TT_SIZE) TT.clear();
      TT.set(key, val);
    }

    function minimaxRootCached(b, depth, player){
      const valid = getValidMoves(b).slice().sort((a,z) => Math.abs(a-3) - Math.abs(z-3));
      let bestCol = valid[0];
      let bestVal = -Infinity;

      for (const col of valid){
        const sim = simulateDrop(b, col, player);
        if (!sim) continue;
        if (checkWinFrom(sim.board, sim.row, sim.col, player).won) return col;

        const val = minimaxCached(sim.board, depth - 1, false, -Infinity, Infinity);
        const total = val + centerBias(col) * 0.2;

        if (total > bestVal){
          bestVal = total;
          bestCol = col;
        }
      }
      return bestCol;
    }

    function minimaxCached(b, depth, maximizing, alpha, beta){
      const playerTurn = maximizing ? AI : HUMAN;
      const key = boardKey(b, playerTurn) + "|d" + depth;

      if (TT.has(key)) return TT.get(key);

      const valid = getValidMoves(b);
      if (depth === 0 || valid.length === 0){
        const base = (evaluateBoard(b, AI) - evaluateBoard(b, HUMAN) * 0.9);
        TTSet(key, base);
        return base;
      }

      const aiWin = findImmediateWin(b, AI);
      const huWin = findImmediateWin(b, HUMAN);
      if (aiWin !== null){ TTSet(key, 100000); return 100000; }
      if (huWin !== null){ TTSet(key, -100000); return -100000; }

      const ordered = valid.slice().sort((a,z) => Math.abs(a-3) - Math.abs(z-3));

      let result;
      if (maximizing){
        let best = -Infinity;
        for (const col of ordered){
          const sim = simulateDrop(b, col, AI);
          if (!sim) continue;
          const val = minimaxCached(sim.board, depth - 1, false, alpha, beta);
          best = Math.max(best, val);
          alpha = Math.max(alpha, best);
          if (beta <= alpha) break;
        }
        result = best;
      } else {
        let best = Infinity;
        for (const col of ordered){
          const sim = simulateDrop(b, col, HUMAN);
          if (!sim) continue;
          const val = minimaxCached(sim.board, depth - 1, true, alpha, beta);
          best = Math.min(best, val);
          beta = Math.min(beta, best);
          if (beta <= alpha) break;
        }
        result = best;
      }

      TTSet(key, result);
      return result;
    }

    // --------- Evaluation (strong heuristic) ----------
    function evaluateBoard(b, player){
      let score = 0;

      // center preference
      const centerCol = 3;
      let centerCount = 0;
      for (let r = 0; r < ROWS; r++){
        if (b[r][centerCol] === player) centerCount++;
      }
      score += centerCount * 6;

      // windows of 4
      for (let r = 0; r < ROWS; r++){
        for (let c = 0; c < COLS - 3; c++){
          score += scoreWindow([b[r][c], b[r][c+1], b[r][c+2], b[r][c+3]], player);
        }
      }
      for (let c = 0; c < COLS; c++){
        for (let r = 0; r < ROWS - 3; r++){
          score += scoreWindow([b[r][c], b[r+1][c], b[r+2][c], b[r+3][c]], player);
        }
      }
      for (let r = 0; r < ROWS - 3; r++){
        for (let c = 0; c < COLS - 3; c++){
          score += scoreWindow([b[r][c], b[r+1][c+1], b[r+2][c+2], b[r+3][c+3]], player);
        }
      }
      for (let r = 0; r < ROWS - 3; r++){
        for (let c = 3; c < COLS; c++){
          score += scoreWindow([b[r][c], b[r+1][c-1], b[r+2][c-2], b[r+3][c-3]], player);
        }
      }

      return score;
    }

    function scoreWindow(window, player){
      const opp = (player === HUMAN ? AI : HUMAN);
      const p = window.filter(v => v === player).length;
      const o = window.filter(v => v === opp).length;
      const e = window.filter(v => v === 0).length;

      // mixed window is neutral
      if (p > 0 && o > 0) return 0;

      if (p === 4) return 10000;
      if (p === 3 && e === 1) return 85;
      if (p === 2 && e === 2) return 12;

      // punish opponent threats harder
      if (o === 3 && e === 1) return -95;
      if (o === 2 && e === 2) return -14;

      return 0;
    }
  </script>
</body>
</html>


